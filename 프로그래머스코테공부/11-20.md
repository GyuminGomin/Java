# 11 ~ 20번

``` java
// 11번 연습문제 -> 뒤에 있는 큰 수 찾기

import java.util.Arrays;
import java.util.Stack;
class Solution {

    public int[] solution(int[] numbers) {

        int n = numbers.length;
        int[] answer = new int[n];
        // [2,3,3,5] -> [3,5,5,-1]
        // [9,1,5,3,6,2] -> [-1,5,6,6,-1,-1]
        
        answer[n-1] = -1;
        Arrays.fill(answer, -1);

        // 뒤에 있는 거 찾아서 가장 큰 수를 반환
        // 중첩 반복문 쓰니 복잡도가 n^2이라 시간 초과가 뜬다.
        // 따라서 뒤에서 부터 스택을 사용
        Stack<Integer> stack = new Stack<>();
        // 스택에 맨 마지막 값 넣어주고
        stack.push(numbers[n-1]);
        for (int i=n-2; i>=0; i--) {
            while (!stack.isEmpty()) {
                if (stack.peek() <= numbers[i]) {
                    stack.pop();
                } else {
                    answer[i] = stack.peek();
                    break;
                }
            }
            stack.push(numbers[i]);
        }

        return answer;
    }
}
public class Main {
    public static void main(String[] args) {
        Solution solution = new Solution();
        // 테스트 케이스 추가하면서 테스트 진행
        System.out.println(Arrays.toString(solution.solution(new int[]{2,3,3,5})));
    }
}

```

``` java
// 12번 스택/큐 -> 다리를 지나는 트럭

// 도저히 못 풀겠다.
```

``` java
// 13번 연습문제 -> 롤케이크 자르기

// 이중중첩문 안쓰려고 하니 도저히 못 풀겠다.

```

``` java
// 14번 연습문제 -> 기사단원의 무기

class Solution {

    private int countDivisors(int number) {
        int count = 0;

        /* - 시간 초과 발생
        for (int i=1; i<=number; i++) {
            if (number%i == 0) {
                count++;
            }
        }
         */

        /* - 시간 초과 발생
        // 짝수일 경우
        if (number%2 == 0) {
            count++; // 1이 반드시 있으므로
            for (int i=2; i<=number; i+=2) {
                if (number%i == 0) {
                    count++;
                }
            }
            // 홀수가 1개 이상 존재할 수 도 있으므로
            while (true) {
                number /= 2;
                if (number == 1) {
                    break;
                }
                if (number%2 == 0) {
                    continue;
                }
                if (number%2 == 1) {
                    for (int i=3; i<=number; i++) {
                        // 1은 추가 했으므로
                        if (number%i == 0) {
                            count++;
                        }
                    }
                    break;
                }
            }
        } else {
            // 홀수일 경우
            for (int i=1; i<=number; i+=2) {
                if (number%i == 0) {
                    count++;
                }
            }
        }
        */

        // 제곱수를 이용한 약수 개수 계산
        // 1. 기본적으로 제곱근에 대해 좌우 대칭으로 약수 개수가 정해짐 (홀수개)
        // 2. 제곱수가 아니라면, 약수의 개수는 (짝수개)로 좌우 대칭
        int sqrt = (int) Math.sqrt(number);

        if (sqrt*sqrt == number) {
            // 제곱수일 경우 약수가 홀수 개 이며, 제곱근이 중복되므로
            count++;
            sqrt--;
        }
        // 제곱근의 값까지 약수를 계산
        for (int i=1; i<=sqrt; i++) {
            if (number%i == 0) {
                // 좌우 대칭이므로 2개씩 더해줌
                count+=2;
            }
        }

        return count;
    }

    public int solution(int number, int limit, int power) {
        int answer = 0;

        // number, limit, power
        // 5, 3, 2
        /*
         * 5 - 1,5 (2)
         * 4 - 1,2,4 (3)
         * 3 - 1,3 (2)
         * 2 - 1,2 (2)
         * 1 - 1 (1)
         */
        // 10, 3, 2
        /*
         * 10 - 1,2,5,10
         */

        int fe = 0;

        for (int i=1; i<=number; i++) {
            // 약수를 구하는 식 적용
            // 이거 중첩 for문 사용하게 되는데 괜찮을려나..?
            int sword = countDivisors(i);
            if (sword > limit) {
                // 제한보다 크면
                sword = power;
            }
            fe += sword;
        }

        answer = fe;
        
        return answer;
    }
}
public class Main {
    public static void main(String[] args) {
        Solution solution = new Solution();
        // 테스트 케이스 추가하면서 테스트 진행
        System.out.println(solution.solution(5,3,2)); 
    }
}
```

``` java
// 15번 연습문제 -> 명예의 전당(1) , PriorityQueue로 계산 가능
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

class Solution {
    public int[] solution(int k, int[] score) {
        int[] answer = {};
        
        // 10, 100, 20, 150, 1, 100, 200
        // k = 3
        /*
         * 10 100 100 150 150 150 200
         *     10  20 100 100 100 150
         *         10  20  20 100 100
         */        
        // 10, 10, 10, 20, 20, 100, 100

        // 큐는 아니다.
        
        List<Integer> list = new LinkedList<>();
        // 채워져 있는지 확인 변수
        // 하나씩 채워 질 때마다 -1;
        int box = k;

        answer = new int[score.length];
        for (int i=0; i<score.length; i++) {
            if (box != 0) {
                list.add(score[i]);
                // 크기 순서대로 저장되지는 않는다.
                box--;

                Collections.sort(list); // 오름 차순
                answer[i] = list.get(0);
            } else {
                // 이제 꽉 채워 지면
                // 리스트에 값을 추가하고
                // 다시 정렬 후
                // 가장 작은 크기를 비운다.
                list.add(score[i]);
                Collections.sort(list);
                list.remove(0);
                answer[i] = list.get(0);
            }
        }

        return answer;
    }
}
public class Main {
    public static void main(String[] args) {
        Solution solution = new Solution();
        // 테스트 케이스 추가하면서 테스트 진행
        System.out.println(Arrays.toString(solution.solution(3, new int[]{10, 100,20, 150, 1, 100, 200}))); 
    }
}
```

``` java
// 16번 연습문제 -> 추억 점수


```